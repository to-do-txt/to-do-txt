let currentRev = null; // Track the version of the file we have

async function loadTasks() {
    try {
        const res = await dbx.filesDownload({ path: '/todo.txt' });
        currentRev = res.result.rev; // Store the revision ID
        const text = await res.result.fileBlob.text();
        allTasks = text.split('\n').filter(t => t.trim() !== "");
        updateSyncStatus('synced');
        render();
    } catch (e) { 
        console.error(e);
        updateSyncStatus('error');
    }
}

async function checkRemoteChanges() {
    if (isRawEditing) return; // Don't interrupt raw editing
    try {
        const meta = await dbx.filesGetMetadata({ path: '/todo.txt' });
        if (meta.result.rev !== currentRev) {
            updateSyncStatus('outdated');
        }
    } catch (e) {
        updateSyncStatus('error');
    }
}

function updateSyncStatus(status) {
    const indicator = document.getElementById('syncIndicator');
    const statusText = document.getElementById('statusText');
    const addBtn = document.querySelector('#addBar button');

    if (status === 'synced') {
        indicator.className = "w-2 h-2 rounded-full bg-green-500";
        statusText.innerText = "v3.3.2 - In Sync";
        addBtn.disabled = false;
        addBtn.innerText = "Add";
    } else if (status === 'outdated') {
        indicator.className = "w-2 h-2 rounded-full bg-yellow-500 animate-pulse";
        statusText.innerHTML = `<span class="text-yellow-500 cursor-pointer underline" onclick="loadTasks()">Update available from remote! Click to Refresh</span>`;
        addBtn.disabled = true;
        addBtn.innerText = "Locked";
    } else if (status === 'error') {
        indicator.className = "w-2 h-2 rounded-full bg-red-500";
        statusText.innerText = "Offline / Sync Error";
    }
}

// Start the polling loop
setInterval(checkRemoteChanges, 30000);
